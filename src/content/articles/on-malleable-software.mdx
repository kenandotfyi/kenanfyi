---
draft: false
title: On Malleable Software
description: my thoughs on software that you can modify
excerpt: "I use Obsidian extensively for my note taking and I have modified it to such an extent that every time I sit in front of my computer to write something, I appreciate their manifesto"
pubDate: 2024-04-28, 19:23
updated: 2024-04-28, 19:23
status: finished
type: article
tags: ["obsidian"]
backlinks: ["tools-i-use", "rust"]
---

import Link from "../../components/Link.astro";

I use Obsidian extensively for my note taking and I have modified it to such an extent that every
time I sit in front of my computer to write something, I appreciate their manifesto. Especially
[this](https://obsidian.md/about#:~:text=Malleable,your%20unique%C2%A0needs.) part:

> ### Malleable
>
> We believe that tools should adapt to your way of thinking, not the other way around. That's why
> we design our tools to be highly customizable and extensible, so you can shape them to your unique
> needs. 

I think a lot about this. In real life, we always try to shape things to our needs.
Clothes, cars, instruments, kitchen stuff... One way or another we change them to work the way we
want them to do. We buy a prebuilt guitar, but change the strings so that we get the sound we want. 
We buy a drawer, we change the knobs to make it look more nicer. But when it comes to
software, we are not like that. Especially in mobile, we are not trying to change how the apps
look or behave. We do not try to attach another piece of functionality. Well, most of the people
don't, but you get the idea.

Even if we'd want, we couldn't, because the software as we use today is mostly a closed system that
works only in certain conditions and certain scenarios. Especially in a corporate environment, you
are stuck in a closed box where you can change more or less nothing, other than some tiny bits which
is hopefully foreseen by the developer(s). Even further, you feel lucky if two different systems can
work with each other. Open source tries to solve that problem by implementing a philosophy where you
can actively participate in the development of a software and keep doing it without any limitations.
Well, almost. But open source is most of the time interested in the development process and it is
also a way to find and interact with like-minded people and get help during your development. It is
a collective effort to bring a piece of software to life, most of the time without the direct goal
of making money. Humanity has seen the benefits of this since the invention of computers. These
sentences you read right now are delivered to you from a server which is using an operating system
built upon the open source philosophy.

So, open source is good, open source is the way that we should develop software. But there is still
a catch between open and closed source software, where the distinction is not only on the philosophy
itself, but also on the people using it:

**The majority are not aware of these two terms.**

Manipulating software is a job for a skilled soul and they are the minority among the public. Not
everyone can change the operating system of their cell phones, even if they are permitted to do so.

This permission is the real key here in my opinion. The conflict between open and closed software is
that closed-source software is owned by an entity where the main goal is to make money, almost all
the time. Understandably this entity does not want to let people make modifications to the software
they have developed. This is basic stuff. We all know a good functioning software needs much effort
from many individuals and at the end of the day, these people need to earn their lives. I'm not
saying something utopic here that all software should be open sourced no matter what. Not gonna go
deep into the never-ending growth mindset, but what I'm saying is, that even if open sourcing
everything is not a realistic thing to expect, **making the software malleable should be the way
that we choose**.

## Malleable Software for Everyone

Another point is the way we interact with the software.

Let's say we have a specific problem and we look for an exact piece of software to solve it. This is
tricky because there must be a good amount of demand to create a special software for that specific
problem, which is mostly not the case. We then use another software that can do many things which
can also do something to ease our problem, but not completely solve it. In the end, we rely on many
tools to do the job. This is in many aspects wrong and time-consuming. Even the context-switching
between environments is hell. A solution could be to contact the developer(s) to implement that bit
of functionality for us, which is extremely unlikely. So we hope for future releases to have that
functionality and keep using the inefficient multiple software toolbox to solve our problem.

The real solution is being **malleable**. Software should be so designed that even people with basic
experience levels could be able to manipulate it, staying in the limits where the software should
still function.

Some are already doing that. Obsidian is the first one that comes to my mind, Raycast is doing a
good job on that too with its easy-to-implement ecosystem and plugin store, Neovim has been doing it
since the beginning, Zotero also has a small but effective plugin ecosystem, VS Code is another one
although I still think they are limiting quite a lot to implement,
[Ink & Switch](https://www.inkandswitch.com/) has so many cool ideas about this too.

<hr />

## Malleable Systems Collective

I've been doing some research about this topic to see if other minds are actively doing some work on
malleable software. Recently, I stumbled upon the
[Malleable Systems Collective](https://malleable.systems/). I recommend checking their mission and
their blog to dig deeper into it.
